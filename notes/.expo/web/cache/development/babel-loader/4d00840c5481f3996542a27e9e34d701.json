{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"@babel/runtime/helpers/asyncToGenerator\");\n\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getApplicationTargetNameForSchemeAsync = getApplicationTargetNameForSchemeAsync;\nexports.getArchiveBuildConfigurationForSchemeAsync = getArchiveBuildConfigurationForSchemeAsync;\nexports.getRunnableSchemesFromXcodeproj = getRunnableSchemesFromXcodeproj;\nexports.getSchemesFromXcodeproj = getSchemesFromXcodeproj;\n\nfunction _XML() {\n  var data = require(\"../utils/XML\");\n\n  _XML = function _XML() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _Paths() {\n  var data = require(\"./Paths\");\n\n  _Paths = function _Paths() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _Target() {\n  var data = require(\"./Target\");\n\n  _Target = function _Target() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _Xcodeproj() {\n  var data = require(\"./utils/Xcodeproj\");\n\n  _Xcodeproj = function _Xcodeproj() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction getSchemesFromXcodeproj(projectRoot) {\n  return (0, _Paths().findSchemeNames)(projectRoot);\n}\n\nfunction getRunnableSchemesFromXcodeproj(projectRoot) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$configuration = _ref.configuration,\n      configuration = _ref$configuration === void 0 ? 'Debug' : _ref$configuration;\n\n  var project = (0, _Xcodeproj().getPbxproj)(projectRoot);\n  return (0, _Target().findSignableTargets)(project).map(function (_ref2) {\n    var _ref3 = _slicedToArray(_ref2, 2),\n        target = _ref3[1];\n\n    var osType = 'iOS';\n    var type = (0, _Xcodeproj().unquote)(target.productType);\n\n    if (type === _Target().TargetType.WATCH) {\n      osType = 'watchOS';\n    } else if (type.startsWith(_Target().TargetType.APPLICATION)) {\n      var xcConfigurationList = project.hash.project.objects.XCConfigurationList[target.buildConfigurationList];\n\n      if (xcConfigurationList) {\n        var buildConfiguration = xcConfigurationList.buildConfigurations.find(function (value) {\n          return value.comment === configuration;\n        }) || xcConfigurationList.buildConfigurations[0];\n\n        if (buildConfiguration !== null && buildConfiguration !== void 0 && buildConfiguration.value) {\n          var _project$hash$project;\n\n          var xcBuildConfiguration = (_project$hash$project = project.hash.project.objects.XCBuildConfiguration) === null || _project$hash$project === void 0 ? void 0 : _project$hash$project[buildConfiguration.value];\n          var buildSdkRoot = xcBuildConfiguration.buildSettings.SDKROOT;\n\n          if (buildSdkRoot === 'appletvos' || 'TVOS_DEPLOYMENT_TARGET' in xcBuildConfiguration.buildSettings) {\n            osType = 'tvOS';\n          } else if (buildSdkRoot === 'iphoneos') {\n            osType = 'iOS';\n          }\n        }\n      }\n    }\n\n    return {\n      name: (0, _Xcodeproj().unquote)(target.name),\n      osType: osType,\n      type: (0, _Xcodeproj().unquote)(target.productType)\n    };\n  });\n}\n\nfunction readSchemeAsync(_x, _x2) {\n  return _readSchemeAsync.apply(this, arguments);\n}\n\nfunction _readSchemeAsync() {\n  _readSchemeAsync = _asyncToGenerator(function* (projectRoot, scheme) {\n    var allSchemePaths = (0, _Paths().findSchemePaths)(projectRoot);\n    var re = new RegExp(\"/\" + scheme + \".xcscheme\", 'i');\n    var schemePath = allSchemePaths.find(function (i) {\n      return re.exec(i);\n    });\n\n    if (schemePath) {\n      return yield (0, _XML().readXMLAsync)({\n        path: schemePath\n      });\n    } else {\n      throw new Error(\"scheme '\" + scheme + \"' does not exist, make sure it's marked as shared\");\n    }\n  });\n  return _readSchemeAsync.apply(this, arguments);\n}\n\nfunction getApplicationTargetNameForSchemeAsync(_x3, _x4) {\n  return _getApplicationTargetNameForSchemeAsync.apply(this, arguments);\n}\n\nfunction _getApplicationTargetNameForSchemeAsync() {\n  _getApplicationTargetNameForSchemeAsync = _asyncToGenerator(function* (projectRoot, scheme) {\n    var _schemeXML$Scheme, _schemeXML$Scheme$Bui, _schemeXML$Scheme$Bui2, _schemeXML$Scheme$Bui3, _schemeXML$Scheme$Bui4;\n\n    var schemeXML = yield readSchemeAsync(projectRoot, scheme);\n    var buildActionEntry = schemeXML === null || schemeXML === void 0 ? void 0 : (_schemeXML$Scheme = schemeXML.Scheme) === null || _schemeXML$Scheme === void 0 ? void 0 : (_schemeXML$Scheme$Bui = _schemeXML$Scheme.BuildAction) === null || _schemeXML$Scheme$Bui === void 0 ? void 0 : (_schemeXML$Scheme$Bui2 = _schemeXML$Scheme$Bui[0]) === null || _schemeXML$Scheme$Bui2 === void 0 ? void 0 : (_schemeXML$Scheme$Bui3 = _schemeXML$Scheme$Bui2.BuildActionEntries) === null || _schemeXML$Scheme$Bui3 === void 0 ? void 0 : (_schemeXML$Scheme$Bui4 = _schemeXML$Scheme$Bui3[0]) === null || _schemeXML$Scheme$Bui4 === void 0 ? void 0 : _schemeXML$Scheme$Bui4.BuildActionEntry;\n    var targetName = (buildActionEntry === null || buildActionEntry === void 0 ? void 0 : buildActionEntry.length) === 1 ? getBlueprintName(buildActionEntry[0]) : getBlueprintName(buildActionEntry === null || buildActionEntry === void 0 ? void 0 : buildActionEntry.find(function (entry) {\n      var _entry$BuildableRefer, _entry$BuildableRefer2, _entry$BuildableRefer3, _entry$BuildableRefer4;\n\n      return (_entry$BuildableRefer = entry.BuildableReference) === null || _entry$BuildableRefer === void 0 ? void 0 : (_entry$BuildableRefer2 = _entry$BuildableRefer[0]) === null || _entry$BuildableRefer2 === void 0 ? void 0 : (_entry$BuildableRefer3 = _entry$BuildableRefer2['$']) === null || _entry$BuildableRefer3 === void 0 ? void 0 : (_entry$BuildableRefer4 = _entry$BuildableRefer3.BuildableName) === null || _entry$BuildableRefer4 === void 0 ? void 0 : _entry$BuildableRefer4.endsWith('.app');\n    }));\n\n    if (!targetName) {\n      throw new Error(scheme + \".xcscheme seems to be corrupted\");\n    }\n\n    return targetName;\n  });\n  return _getApplicationTargetNameForSchemeAsync.apply(this, arguments);\n}\n\nfunction getArchiveBuildConfigurationForSchemeAsync(_x5, _x6) {\n  return _getArchiveBuildConfigurationForSchemeAsync.apply(this, arguments);\n}\n\nfunction _getArchiveBuildConfigurationForSchemeAsync() {\n  _getArchiveBuildConfigurationForSchemeAsync = _asyncToGenerator(function* (projectRoot, scheme) {\n    var _schemeXML$Scheme2, _schemeXML$Scheme2$Ar, _schemeXML$Scheme2$Ar2, _schemeXML$Scheme2$Ar3;\n\n    var schemeXML = yield readSchemeAsync(projectRoot, scheme);\n    var buildConfiguration = schemeXML === null || schemeXML === void 0 ? void 0 : (_schemeXML$Scheme2 = schemeXML.Scheme) === null || _schemeXML$Scheme2 === void 0 ? void 0 : (_schemeXML$Scheme2$Ar = _schemeXML$Scheme2.ArchiveAction) === null || _schemeXML$Scheme2$Ar === void 0 ? void 0 : (_schemeXML$Scheme2$Ar2 = _schemeXML$Scheme2$Ar[0]) === null || _schemeXML$Scheme2$Ar2 === void 0 ? void 0 : (_schemeXML$Scheme2$Ar3 = _schemeXML$Scheme2$Ar2['$']) === null || _schemeXML$Scheme2$Ar3 === void 0 ? void 0 : _schemeXML$Scheme2$Ar3.buildConfiguration;\n\n    if (!buildConfiguration) {\n      throw new Error(scheme + \".xcscheme seems to be corrupted\");\n    }\n\n    return buildConfiguration;\n  });\n  return _getArchiveBuildConfigurationForSchemeAsync.apply(this, arguments);\n}\n\nfunction getBlueprintName(entry) {\n  var _entry$BuildableRefer5, _entry$BuildableRefer6, _entry$BuildableRefer7;\n\n  return entry === null || entry === void 0 ? void 0 : (_entry$BuildableRefer5 = entry.BuildableReference) === null || _entry$BuildableRefer5 === void 0 ? void 0 : (_entry$BuildableRefer6 = _entry$BuildableRefer5[0]) === null || _entry$BuildableRefer6 === void 0 ? void 0 : (_entry$BuildableRefer7 = _entry$BuildableRefer6['$']) === null || _entry$BuildableRefer7 === void 0 ? void 0 : _entry$BuildableRefer7.BlueprintName;\n}","map":{"version":3,"mappings":"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","names":["_XML","_Paths","_Target","_Xcodeproj","getSchemesFromXcodeproj","projectRoot","getRunnableSchemesFromXcodeproj","configuration","project","map","target","osType","type","productType","TargetType","WATCH","startsWith","APPLICATION","xcConfigurationList","hash","objects","XCConfigurationList","buildConfigurationList","buildConfiguration","buildConfigurations","find","value","comment","xcBuildConfiguration","XCBuildConfiguration","_project$hash$project","buildSdkRoot","buildSettings","SDKROOT","name","readSchemeAsync","scheme","allSchemePaths","re","RegExp","schemePath","i","exec","path","Error","getApplicationTargetNameForSchemeAsync","schemeXML","buildActionEntry","Scheme","_schemeXML$Scheme","BuildAction","_schemeXML$Scheme$Bui","_schemeXML$Scheme$Bui2","BuildActionEntries","_schemeXML$Scheme$Bui3","_schemeXML$Scheme$Bui4","BuildActionEntry","targetName","length","getBlueprintName","entry","BuildableReference","_entry$BuildableRefer","_entry$BuildableRefer2","_entry$BuildableRefer3","BuildableName","_entry$BuildableRefer4","endsWith","getArchiveBuildConfigurationForSchemeAsync","_schemeXML$Scheme2","ArchiveAction","_schemeXML$Scheme2$Ar","_schemeXML$Scheme2$Ar2","_schemeXML$Scheme2$Ar3","_entry$BuildableRefer5","_entry$BuildableRefer6","_entry$BuildableRefer7","BlueprintName"],"sources":["../../src/ios/BuildScheme.ts"],"sourcesContent":["import { readXMLAsync } from '../utils/XML';\nimport { findSchemeNames, findSchemePaths } from './Paths';\nimport { findSignableTargets, TargetType } from './Target';\nimport { getPbxproj, unquote } from './utils/Xcodeproj';\n\ninterface SchemeXML {\n  Scheme?: {\n    BuildAction?: {\n      BuildActionEntries?: {\n        BuildActionEntry?: BuildActionEntryType[];\n      }[];\n    }[];\n    ArchiveAction?: {\n      $?: {\n        buildConfiguration?: string;\n      };\n    }[];\n  };\n}\n\ninterface BuildActionEntryType {\n  BuildableReference?: {\n    $?: {\n      BlueprintName?: string;\n      BuildableName?: string;\n    };\n  }[];\n}\n\nexport function getSchemesFromXcodeproj(projectRoot: string): string[] {\n  return findSchemeNames(projectRoot);\n}\n\nexport function getRunnableSchemesFromXcodeproj(\n  projectRoot: string,\n  { configuration = 'Debug' }: { configuration?: 'Debug' | 'Release' } = {}\n): { name: string; osType: string; type: string }[] {\n  const project = getPbxproj(projectRoot);\n\n  return findSignableTargets(project).map(([, target]) => {\n    let osType = 'iOS';\n    const type = unquote(target.productType);\n\n    if (type === TargetType.WATCH) {\n      osType = 'watchOS';\n    } else if (\n      // (apps) com.apple.product-type.application\n      // (app clips) com.apple.product-type.application.on-demand-install-capable\n      // NOTE(EvanBacon): This matches against `watchOS` as well so we check for watch first.\n      type.startsWith(TargetType.APPLICATION)\n    ) {\n      // Attempt to resolve the platform SDK for each target so we can filter devices.\n      const xcConfigurationList =\n        project.hash.project.objects.XCConfigurationList[target.buildConfigurationList];\n\n      if (xcConfigurationList) {\n        const buildConfiguration =\n          xcConfigurationList.buildConfigurations.find(\n            (value: { comment: string; value: string }) => value.comment === configuration\n          ) || xcConfigurationList.buildConfigurations[0];\n        if (buildConfiguration?.value) {\n          const xcBuildConfiguration =\n            project.hash.project.objects.XCBuildConfiguration?.[buildConfiguration.value];\n\n          const buildSdkRoot = xcBuildConfiguration.buildSettings.SDKROOT;\n          if (\n            buildSdkRoot === 'appletvos' ||\n            'TVOS_DEPLOYMENT_TARGET' in xcBuildConfiguration.buildSettings\n          ) {\n            // Is a TV app...\n            osType = 'tvOS';\n          } else if (buildSdkRoot === 'iphoneos') {\n            osType = 'iOS';\n          }\n        }\n      }\n    }\n\n    return {\n      name: unquote(target.name),\n      osType,\n      type: unquote(target.productType),\n    };\n  });\n}\n\nasync function readSchemeAsync(\n  projectRoot: string,\n  scheme: string\n): Promise<SchemeXML | undefined> {\n  const allSchemePaths = findSchemePaths(projectRoot);\n  const re = new RegExp(`/${scheme}.xcscheme`, 'i');\n  const schemePath = allSchemePaths.find((i) => re.exec(i));\n  if (schemePath) {\n    return (await readXMLAsync({ path: schemePath })) as unknown as SchemeXML | undefined;\n  } else {\n    throw new Error(`scheme '${scheme}' does not exist, make sure it's marked as shared`);\n  }\n}\n\nexport async function getApplicationTargetNameForSchemeAsync(\n  projectRoot: string,\n  scheme: string\n): Promise<string> {\n  const schemeXML = await readSchemeAsync(projectRoot, scheme);\n  const buildActionEntry =\n    schemeXML?.Scheme?.BuildAction?.[0]?.BuildActionEntries?.[0]?.BuildActionEntry;\n  const targetName =\n    buildActionEntry?.length === 1\n      ? getBlueprintName(buildActionEntry[0])\n      : getBlueprintName(\n          buildActionEntry?.find((entry) => {\n            return entry.BuildableReference?.[0]?.['$']?.BuildableName?.endsWith('.app');\n          })\n        );\n  if (!targetName) {\n    throw new Error(`${scheme}.xcscheme seems to be corrupted`);\n  }\n  return targetName;\n}\n\nexport async function getArchiveBuildConfigurationForSchemeAsync(\n  projectRoot: string,\n  scheme: string\n): Promise<string> {\n  const schemeXML = await readSchemeAsync(projectRoot, scheme);\n  const buildConfiguration = schemeXML?.Scheme?.ArchiveAction?.[0]?.['$']?.buildConfiguration;\n  if (!buildConfiguration) {\n    throw new Error(`${scheme}.xcscheme seems to be corrupted`);\n  }\n  return buildConfiguration;\n}\n\nfunction getBlueprintName(entry?: BuildActionEntryType): string | undefined {\n  return entry?.BuildableReference?.[0]?.['$']?.BlueprintName;\n}\n"]},"metadata":{},"sourceType":"script"}