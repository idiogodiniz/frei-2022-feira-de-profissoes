{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\n\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\n\nvar _objectWithoutProperties = require(\"@babel/runtime/helpers/objectWithoutProperties\");\n\nvar _asyncToGenerator = require(\"@babel/runtime/helpers/asyncToGenerator\");\n\nvar _excluded = [\"modRequest\"],\n    _excluded2 = [\"nextMod\"],\n    _excluded3 = [\"modRequest\", \"modResults\"];\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.withBaseMod = withBaseMod;\nexports.withMod = withMod;\n\nfunction _chalk() {\n  var data = _interopRequireDefault(require(\"chalk\"));\n\n  _chalk = function _chalk() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _getenv() {\n  var data = require(\"getenv\");\n\n  _getenv = function _getenv() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _errors() {\n  var data = require(\"../utils/errors\");\n\n  _errors = function _errors() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar EXPO_DEBUG = (0, _getenv().boolish)('EXPO_DEBUG', false);\n\nfunction withBaseMod(config, _ref2) {\n  var platform = _ref2.platform,\n      mod = _ref2.mod,\n      action = _ref2.action,\n      skipEmptyMod = _ref2.skipEmptyMod,\n      isProvider = _ref2.isProvider,\n      isIntrospective = _ref2.isIntrospective,\n      saveToInternal = _ref2.saveToInternal;\n\n  var _config$_internal$isD, _config$_internal;\n\n  if (!config.mods) {\n    config.mods = {};\n  }\n\n  if (!config.mods[platform]) {\n    config.mods[platform] = {};\n  }\n\n  var interceptedMod = config.mods[platform][mod];\n\n  if (!interceptedMod) {\n    if (skipEmptyMod) {\n      return config;\n    }\n\n    var noopMod = function noopMod(config) {\n      return config;\n    };\n\n    interceptedMod = noopMod;\n  }\n\n  var debugTrace = '';\n  var isDebug = (_config$_internal$isD = (_config$_internal = config._internal) === null || _config$_internal === void 0 ? void 0 : _config$_internal.isDebug) !== null && _config$_internal$isD !== void 0 ? _config$_internal$isD : EXPO_DEBUG;\n\n  if (isDebug) {\n    var stack = new Error().stack;\n    debugTrace = getDebugPluginStackFromStackTrace(stack);\n\n    var modStack = _chalk().default.bold(platform + \".\" + mod);\n\n    debugTrace = modStack + \": \" + debugTrace;\n  }\n\n  if (interceptedMod.isProvider) {\n    if (isProvider) {\n      throw new (_errors().PluginError)(\"Cannot set provider mod for \\\"\" + platform + \".\" + mod + \"\\\" because another is already being used.\", 'CONFLICTING_PROVIDER');\n    } else {\n      throw new (_errors().PluginError)(\"Cannot add mod to \\\"\" + platform + \".\" + mod + \"\\\" because the provider has already been added. Provider must be the last mod added.\", 'INVALID_MOD_ORDER');\n    }\n  }\n\n  function interceptingMod(_x) {\n    return _interceptingMod.apply(this, arguments);\n  }\n\n  function _interceptingMod() {\n    _interceptingMod = _asyncToGenerator(function* (_ref3) {\n      var modRequest = _ref3.modRequest,\n          config = _objectWithoutProperties(_ref3, _excluded);\n\n      if (isDebug) {\n        console.log(debugTrace);\n      }\n\n      var results = yield action(_objectSpread(_objectSpread({}, config), {}, {\n        modRequest: _objectSpread(_objectSpread({}, modRequest), {}, {\n          nextMod: interceptedMod\n        })\n      }));\n\n      if (saveToInternal) {\n        saveToInternalObject(results, platform, mod, results.modResults);\n      }\n\n      return results;\n    });\n    return _interceptingMod.apply(this, arguments);\n  }\n\n  interceptingMod.isProvider = isProvider;\n\n  if (isIntrospective) {\n    interceptingMod.isIntrospective = isIntrospective;\n  }\n\n  config.mods[platform][mod] = interceptingMod;\n  return config;\n}\n\nfunction saveToInternalObject(config, platformName, modName, results) {\n  if (!config._internal) config._internal = {};\n  if (!config._internal.modResults) config._internal.modResults = {};\n  if (!config._internal.modResults[platformName]) config._internal.modResults[platformName] = {};\n  config._internal.modResults[platformName][modName] = results;\n}\n\nfunction getDebugPluginStackFromStackTrace(stacktrace) {\n  if (!stacktrace) {\n    return '';\n  }\n\n  var treeStackLines = [];\n\n  for (var line of stacktrace.split('\\n')) {\n    var _line$trim$split = line.trim().split(' '),\n        _line$trim$split2 = _slicedToArray(_line$trim$split, 2),\n        first = _line$trim$split2[0],\n        second = _line$trim$split2[1];\n\n    if (first === 'at') {\n      treeStackLines.push(second);\n    }\n  }\n\n  var plugins = treeStackLines.map(function (first) {\n    var _ref, _first$match$1$trim, _first$match, _first$match$, _first$match2, _first$match2$;\n\n    return (_ref = (_first$match$1$trim = first === null || first === void 0 ? void 0 : (_first$match = first.match(/^(\\bwith[A-Z].*?\\b)/)) === null || _first$match === void 0 ? void 0 : (_first$match$ = _first$match[1]) === null || _first$match$ === void 0 ? void 0 : _first$match$.trim()) !== null && _first$match$1$trim !== void 0 ? _first$match$1$trim : first === null || first === void 0 ? void 0 : (_first$match2 = first.match(/\\.(\\bwith[A-Z].*?\\b)/)) === null || _first$match2 === void 0 ? void 0 : (_first$match2$ = _first$match2[1]) === null || _first$match2$ === void 0 ? void 0 : _first$match2$.trim()) !== null && _ref !== void 0 ? _ref : null;\n  }).filter(Boolean).filter(function (plugin) {\n    return !['withMod', 'withBaseMod', 'withExtendedMod'].includes(plugin);\n  });\n  var commonPlugins = ['withPlugins', 'withRunOnce', 'withStaticPlugin'];\n  return plugins.reverse().map(function (pluginName, index) {\n    if (pluginName.includes('BaseMod')) {\n      pluginName = _chalk().default.bold(pluginName);\n    }\n\n    if (pluginName.toLowerCase().includes('dangerous')) {\n      pluginName = _chalk().default.red(pluginName);\n    }\n\n    if (index === 0) {\n      return _chalk().default.blue(pluginName);\n    } else if (commonPlugins.includes(pluginName)) {\n      return _chalk().default.dim(pluginName);\n    }\n\n    return pluginName;\n  }).join(' ➜ ');\n}\n\nfunction withMod(config, _ref4) {\n  var platform = _ref4.platform,\n      mod = _ref4.mod,\n      _action = _ref4.action;\n  return withBaseMod(config, {\n    platform: platform,\n    mod: mod,\n    isProvider: false,\n    action: function () {\n      var _action2 = _asyncToGenerator(function* (_ref5) {\n        var _ref5$modRequest = _ref5.modRequest,\n            nextMod = _ref5$modRequest.nextMod,\n            modRequest = _objectWithoutProperties(_ref5$modRequest, _excluded2),\n            modResults = _ref5.modResults,\n            config = _objectWithoutProperties(_ref5, _excluded3);\n\n        var results = yield _action(_objectSpread({\n          modRequest: modRequest,\n          modResults: modResults\n        }, config));\n        return nextMod(results);\n      });\n\n      function action(_x2) {\n        return _action2.apply(this, arguments);\n      }\n\n      return action;\n    }()\n  });\n}","map":{"version":3,"mappings":"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","names":["_chalk","_getenv","_errors","EXPO_DEBUG","withBaseMod","config","platform","mod","action","skipEmptyMod","isProvider","isIntrospective","saveToInternal","mods","interceptedMod","noopMod","debugTrace","isDebug","_internal","_config$_internal","stack","Error","getDebugPluginStackFromStackTrace","modStack","chalk","bold","PluginError","interceptingMod","modRequest","console","log","results","nextMod","saveToInternalObject","modResults","platformName","modName","stacktrace","treeStackLines","line","split","trim","first","second","push","plugins","map","match","_first$match","_first$match$","_first$match2","_first$match2$","filter","Boolean","plugin","includes","commonPlugins","reverse","pluginName","index","toLowerCase","red","blue","dim","join","withMod"],"sources":["../../src/plugins/withMod.ts"],"sourcesContent":["import { ExpoConfig } from '@expo/config-types';\nimport { JSONObject } from '@expo/json-file';\nimport chalk from 'chalk';\nimport { boolish } from 'getenv';\n\nimport { ExportedConfig, ExportedConfigWithProps, Mod, ModPlatform } from '../Plugin.types';\nimport { PluginError } from '../utils/errors';\n\nconst EXPO_DEBUG = boolish('EXPO_DEBUG', false);\n\nexport type BaseModOptions = {\n  platform: ModPlatform;\n  mod: string;\n  isProvider?: boolean;\n  skipEmptyMod?: boolean;\n  saveToInternal?: boolean;\n  /**\n   * If the mod supports introspection, and avoids making any filesystem modifications during compilation.\n   * By enabling, this mod, and all of its descendants will be run in introspection mode.\n   * This should only be used for static files like JSON or XML, and not for application files that require regexes,\n   * or complex static files that require other files to be generated like Xcode `.pbxproj`.\n   */\n  isIntrospective?: boolean;\n};\n\n/**\n * Plugin to intercept execution of a given `mod` with the given `action`.\n * If an action was already set on the given `config` config for `mod`, then it\n * will be provided to the `action` as `nextMod` when it's evaluated, otherwise\n * `nextMod` will be an identity function.\n *\n * @param config exported config\n * @param platform platform to target (ios or android)\n * @param mod name of the platform function to intercept\n * @param skipEmptyMod should skip running the action if there is no existing mod to intercept\n * @param saveToInternal should save the results to `_internal.modResults`, only enable this when the results are pure JSON.\n * @param isProvider should provide data up to the other mods.\n * @param action method to run on the mod when the config is compiled\n */\nexport function withBaseMod<T>(\n  config: ExportedConfig,\n  {\n    platform,\n    mod,\n    action,\n    skipEmptyMod,\n    isProvider,\n    isIntrospective,\n    saveToInternal,\n  }: BaseModOptions & { action: Mod<T> }\n): ExportedConfig {\n  if (!config.mods) {\n    config.mods = {};\n  }\n  if (!config.mods[platform]) {\n    config.mods[platform] = {};\n  }\n\n  let interceptedMod: Mod<T> = (config.mods[platform] as Record<string, any>)[mod];\n\n  // No existing mod to intercept\n  if (!interceptedMod) {\n    if (skipEmptyMod) {\n      // Skip running the action\n      return config;\n    }\n    // Use a noop mod and continue\n    const noopMod: Mod<T> = (config) => config;\n    interceptedMod = noopMod;\n  }\n\n  // Create a stack trace for debugging ahead of time\n  let debugTrace: string = '';\n  // Use the possibly user defined value. Otherwise fallback to the env variable.\n  // We support the env variable because user mods won't have _internal defined in time.\n  const isDebug = config._internal?.isDebug ?? EXPO_DEBUG;\n  if (isDebug) {\n    // Get a stack trace via the Error API\n    const stack = new Error().stack;\n    // Format the stack trace to create the debug log\n    debugTrace = getDebugPluginStackFromStackTrace(stack);\n    const modStack = chalk.bold(`${platform}.${mod}`);\n\n    debugTrace = `${modStack}: ${debugTrace}`;\n  }\n\n  // Prevent adding multiple providers to a mod.\n  // Base mods that provide files ignore any incoming modResults and therefore shouldn't have provider mods as parents.\n  if (interceptedMod.isProvider) {\n    if (isProvider) {\n      throw new PluginError(\n        `Cannot set provider mod for \"${platform}.${mod}\" because another is already being used.`,\n        'CONFLICTING_PROVIDER'\n      );\n    } else {\n      throw new PluginError(\n        `Cannot add mod to \"${platform}.${mod}\" because the provider has already been added. Provider must be the last mod added.`,\n        'INVALID_MOD_ORDER'\n      );\n    }\n  }\n\n  async function interceptingMod({ modRequest, ...config }: ExportedConfigWithProps<T>) {\n    if (isDebug) {\n      // In debug mod, log the plugin stack in the order which they were invoked\n      console.log(debugTrace);\n    }\n    const results = await action({\n      ...config,\n      modRequest: { ...modRequest, nextMod: interceptedMod },\n    });\n\n    if (saveToInternal) {\n      saveToInternalObject(results, platform, mod, results.modResults as unknown as JSONObject);\n    }\n    return results;\n  }\n\n  // Ensure this base mod is registered as the provider.\n  interceptingMod.isProvider = isProvider;\n\n  if (isIntrospective) {\n    // Register the mode as idempotent so introspection doesn't remove it.\n    interceptingMod.isIntrospective = isIntrospective;\n  }\n\n  (config.mods[platform] as any)[mod] = interceptingMod;\n\n  return config;\n}\n\nfunction saveToInternalObject(\n  config: Pick<ExpoConfig, '_internal'>,\n  platformName: ModPlatform,\n  modName: string,\n  results: JSONObject\n) {\n  if (!config._internal) config._internal = {};\n  if (!config._internal.modResults) config._internal.modResults = {};\n  if (!config._internal.modResults[platformName]) config._internal.modResults[platformName] = {};\n  config._internal.modResults[platformName][modName] = results;\n}\n\nfunction getDebugPluginStackFromStackTrace(stacktrace?: string): string {\n  if (!stacktrace) {\n    return '';\n  }\n\n  const treeStackLines: string[] = [];\n  for (const line of stacktrace.split('\\n')) {\n    const [first, second] = line.trim().split(' ');\n    if (first === 'at') {\n      treeStackLines.push(second);\n    }\n  }\n\n  const plugins = treeStackLines\n    .map((first) => {\n      // Match the first part of the stack trace against the plugin naming convention\n      // \"with\" followed by a capital letter.\n      return (\n        first?.match(/^(\\bwith[A-Z].*?\\b)/)?.[1]?.trim() ??\n        first?.match(/\\.(\\bwith[A-Z].*?\\b)/)?.[1]?.trim() ??\n        null\n      );\n    })\n    .filter(Boolean)\n    .filter((plugin) => {\n      // redundant as all debug logs are captured in withBaseMod\n      return !['withMod', 'withBaseMod', 'withExtendedMod'].includes(plugin!);\n    });\n\n  const commonPlugins = ['withPlugins', 'withRunOnce', 'withStaticPlugin'];\n\n  return (\n    (plugins as string[])\n      .reverse()\n      .map((pluginName, index) => {\n        // Base mods indicate a logical section.\n        if (pluginName.includes('BaseMod')) {\n          pluginName = chalk.bold(pluginName);\n        }\n        // highlight dangerous mods\n        if (pluginName.toLowerCase().includes('dangerous')) {\n          pluginName = chalk.red(pluginName);\n        }\n\n        if (index === 0) {\n          return chalk.blue(pluginName);\n        } else if (commonPlugins.includes(pluginName)) {\n          // Common mod names often clutter up the logs, dim them out\n          return chalk.dim(pluginName);\n        }\n        return pluginName;\n      })\n      // Join the results:\n      // withAndroidExpoPlugins ➜ withPlugins ➜ withIcons ➜ withDangerousMod ➜ withMod\n      .join(' ➜ ')\n  );\n}\n\n/**\n * Plugin to extend a mod function in the plugins config.\n *\n * @param config exported config\n * @param platform platform to target (ios or android)\n * @param mod name of the platform function to extend\n * @param action method to run on the mod when the config is compiled\n */\nexport function withMod<T>(\n  config: ExportedConfig,\n  {\n    platform,\n    mod,\n    action,\n  }: {\n    platform: ModPlatform;\n    mod: string;\n    action: Mod<T>;\n  }\n): ExportedConfig {\n  return withBaseMod(config, {\n    platform,\n    mod,\n    isProvider: false,\n    async action({ modRequest: { nextMod, ...modRequest }, modResults, ...config }) {\n      const results = await action({ modRequest, modResults: modResults as T, ...config });\n      return nextMod!(results as any);\n    },\n  });\n}\n"]},"metadata":{},"sourceType":"script"}